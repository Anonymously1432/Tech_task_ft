// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: applications.sql

package application

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications(user_id, product_id, data, calculated_price, manager_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, status, calculated_price, created_at
`

type CreateApplicationParams struct {
	UserID          *int32         `db:"user_id" json:"user_id"`
	ProductID       *int32         `db:"product_id" json:"product_id"`
	Data            []byte         `db:"data" json:"data"`
	CalculatedPrice pgtype.Numeric `db:"calculated_price" json:"calculated_price"`
	ManagerID       *int32         `db:"manager_id" json:"manager_id"`
}

type CreateApplicationRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg *CreateApplicationParams) (*CreateApplicationRow, error) {
	row := q.db.QueryRow(ctx, createApplication,
		arg.UserID,
		arg.ProductID,
		arg.Data,
		arg.CalculatedPrice,
		arg.ManagerID,
	)
	var i CreateApplicationRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CalculatedPrice,
		&i.CreatedAt,
	)
	return &i, err
}

const createApplicationComment = `-- name: CreateApplicationComment :exec
INSERT INTO application_comments (
    application_id,
    author_role,
    comment,
    created_at
) VALUES (
    $1,
    'MANAGER',
    $2,
    NOW()
)
`

type CreateApplicationCommentParams struct {
	ApplicationID *int32 `db:"application_id" json:"application_id"`
	Comment       string `db:"comment" json:"comment"`
}

func (q *Queries) CreateApplicationComment(ctx context.Context, arg *CreateApplicationCommentParams) error {
	_, err := q.db.Exec(ctx, createApplicationComment, arg.ApplicationID, arg.Comment)
	return err
}

const createApplicationCommentt = `-- name: CreateApplicationCommentt :one
INSERT INTO application_comments (
    application_id,
    user_id,
    comment,
    created_at
) VALUES (
             $1,
             $2,
             $3,
             NOW()
         )
    RETURNING id, comment, created_at
`

type CreateApplicationCommenttParams struct {
	ApplicationID *int32 `db:"application_id" json:"application_id"`
	UserID        *int32 `db:"user_id" json:"user_id"`
	Comment       string `db:"comment" json:"comment"`
}

type CreateApplicationCommenttRow struct {
	ID        int32            `db:"id" json:"id"`
	Comment   string           `db:"comment" json:"comment"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateApplicationCommentt(ctx context.Context, arg *CreateApplicationCommenttParams) (*CreateApplicationCommenttRow, error) {
	row := q.db.QueryRow(ctx, createApplicationCommentt, arg.ApplicationID, arg.UserID, arg.Comment)
	var i CreateApplicationCommenttRow
	err := row.Scan(&i.ID, &i.Comment, &i.CreatedAt)
	return &i, err
}

const getApplicationByID = `-- name: GetApplicationByID :one
SELECT
    a.id,
    a.status,
    a.data,
    a.calculated_price,
    a.created_at,
    p.type AS product_type
FROM applications a
         JOIN products p ON a.product_id = p.id
WHERE a.id = $1
`

type GetApplicationByIDParams struct {
	ID int32 `db:"id" json:"id"`
}

type GetApplicationByIDRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	Data            []byte           `db:"data" json:"data"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	ProductType     string           `db:"product_type" json:"product_type"`
}

func (q *Queries) GetApplicationByID(ctx context.Context, arg *GetApplicationByIDParams) (*GetApplicationByIDRow, error) {
	row := q.db.QueryRow(ctx, getApplicationByID, arg.ID)
	var i GetApplicationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Data,
		&i.CalculatedPrice,
		&i.CreatedAt,
		&i.ProductType,
	)
	return &i, err
}

const getApplicationComments = `-- name: GetApplicationComments :many
SELECT
    ac.id,
    ac.comment,
    ac.created_at,
    u.id        AS author_id,
    u.full_name AS author_full_name
FROM application_comments ac
         JOIN users u ON ac.user_id = u.id
WHERE ac.application_id = $1
ORDER BY ac.created_at ASC
`

type GetApplicationCommentsParams struct {
	ApplicationID *int32 `db:"application_id" json:"application_id"`
}

type GetApplicationCommentsRow struct {
	ID             int32            `db:"id" json:"id"`
	Comment        string           `db:"comment" json:"comment"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	AuthorID       int32            `db:"author_id" json:"author_id"`
	AuthorFullName string           `db:"author_full_name" json:"author_full_name"`
}

func (q *Queries) GetApplicationComments(ctx context.Context, arg *GetApplicationCommentsParams) ([]*GetApplicationCommentsRow, error) {
	rows, err := q.db.Query(ctx, getApplicationComments, arg.ApplicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetApplicationCommentsRow
	for rows.Next() {
		var i GetApplicationCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Comment,
			&i.CreatedAt,
			&i.AuthorID,
			&i.AuthorFullName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationStatusHistory = `-- name: GetApplicationStatusHistory :many
SELECT
    old_status,
    new_status,
    changed_by,
    comment,
    created_at
FROM application_status_history
WHERE application_id = $1
ORDER BY created_at ASC
`

type GetApplicationStatusHistoryParams struct {
	ApplicationID *int32 `db:"application_id" json:"application_id"`
}

type GetApplicationStatusHistoryRow struct {
	OldStatus *string          `db:"old_status" json:"old_status"`
	NewStatus string           `db:"new_status" json:"new_status"`
	ChangedBy *int32           `db:"changed_by" json:"changed_by"`
	Comment   *string          `db:"comment" json:"comment"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) GetApplicationStatusHistory(ctx context.Context, arg *GetApplicationStatusHistoryParams) ([]*GetApplicationStatusHistoryRow, error) {
	rows, err := q.db.Query(ctx, getApplicationStatusHistory, arg.ApplicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetApplicationStatusHistoryRow
	for rows.Next() {
		var i GetApplicationStatusHistoryRow
		if err := rows.Scan(
			&i.OldStatus,
			&i.NewStatus,
			&i.ChangedBy,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplications = `-- name: GetApplications :many
SELECT
    a.id,
    a.status,
    a.calculated_price,
    a.created_at,
    p.type AS product_type
FROM applications a
         JOIN products p ON a.product_id = p.id
WHERE a.user_id = $1
  AND ($2::text IS NULL OR a.status = $2)
ORDER BY a.created_at DESC
    LIMIT $3 OFFSET $4
`

type GetApplicationsParams struct {
	UserID  *int32 `db:"user_id" json:"user_id"`
	Column2 string `db:"column_2" json:"column_2"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

type GetApplicationsRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	ProductType     string           `db:"product_type" json:"product_type"`
}

func (q *Queries) GetApplications(ctx context.Context, arg *GetApplicationsParams) ([]*GetApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getApplications,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetApplicationsRow
	for rows.Next() {
		var i GetApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CalculatedPrice,
			&i.CreatedAt,
			&i.ProductType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsCount = `-- name: GetApplicationsCount :one
SELECT COUNT(*) AS total
FROM applications
WHERE user_id = $1
  AND ($2::text IS NULL OR status = $2)
`

type GetApplicationsCountParams struct {
	UserID  *int32 `db:"user_id" json:"user_id"`
	Column2 string `db:"column_2" json:"column_2"`
}

func (q *Queries) GetApplicationsCount(ctx context.Context, arg *GetApplicationsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getApplicationsCount, arg.UserID, arg.Column2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getManagerApplicationByID = `-- name: GetManagerApplicationByID :one
SELECT
    a.id,
    a.status,
    a.data,
    a.calculated_price,
    a.created_at,
    p.type AS product_type,
    u.id        AS client_id,
    u.full_name AS client_full_name,
    u.email     AS client_email,
    u.phone     AS client_phone
FROM applications a
         JOIN users u ON a.user_id = u.id
         JOIN products p ON a.product_id = p.id
WHERE a.id = $1
`

type GetManagerApplicationByIDParams struct {
	ID int32 `db:"id" json:"id"`
}

type GetManagerApplicationByIDRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	Data            []byte           `db:"data" json:"data"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	ProductType     string           `db:"product_type" json:"product_type"`
	ClientID        int32            `db:"client_id" json:"client_id"`
	ClientFullName  string           `db:"client_full_name" json:"client_full_name"`
	ClientEmail     string           `db:"client_email" json:"client_email"`
	ClientPhone     *string          `db:"client_phone" json:"client_phone"`
}

func (q *Queries) GetManagerApplicationByID(ctx context.Context, arg *GetManagerApplicationByIDParams) (*GetManagerApplicationByIDRow, error) {
	row := q.db.QueryRow(ctx, getManagerApplicationByID, arg.ID)
	var i GetManagerApplicationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Data,
		&i.CalculatedPrice,
		&i.CreatedAt,
		&i.ProductType,
		&i.ClientID,
		&i.ClientFullName,
		&i.ClientEmail,
		&i.ClientPhone,
	)
	return &i, err
}

const getManagerApplications = `-- name: GetManagerApplications :many
SELECT
    a.id,
    a.status,
    a.calculated_price,
    a.created_at,
    u.id        AS client_id,
    u.full_name AS client_full_name,
    u.email     AS client_email,
    p.type      AS product_type
FROM applications a
    JOIN users u ON a.user_id = u.id
    JOIN products p ON a.product_id = p.id
WHERE
    ($1::text IS NULL OR a.status = $1)
  AND ($2::text IS NULL OR p.type = $2)
  AND ($3::timestamp IS NULL OR a.created_at >= $3)
  AND ($4::timestamp IS NULL OR a.created_at <= $4)
  AND ($5::int IS NULL OR u.id = $5)
ORDER BY a.created_at DESC
    LIMIT $6 OFFSET $7
`

type GetManagerApplicationsParams struct {
	Column1 string           `db:"column_1" json:"column_1"`
	Column2 string           `db:"column_2" json:"column_2"`
	Column3 pgtype.Timestamp `db:"column_3" json:"column_3"`
	Column4 pgtype.Timestamp `db:"column_4" json:"column_4"`
	Column5 int32            `db:"column_5" json:"column_5"`
	Limit   int32            `db:"limit" json:"limit"`
	Offset  int32            `db:"offset" json:"offset"`
}

type GetManagerApplicationsRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	ClientID        int32            `db:"client_id" json:"client_id"`
	ClientFullName  string           `db:"client_full_name" json:"client_full_name"`
	ClientEmail     string           `db:"client_email" json:"client_email"`
	ProductType     string           `db:"product_type" json:"product_type"`
}

func (q *Queries) GetManagerApplications(ctx context.Context, arg *GetManagerApplicationsParams) ([]*GetManagerApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getManagerApplications,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetManagerApplicationsRow
	for rows.Next() {
		var i GetManagerApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CalculatedPrice,
			&i.CreatedAt,
			&i.ClientID,
			&i.ClientFullName,
			&i.ClientEmail,
			&i.ProductType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManagerApplicationsCount = `-- name: GetManagerApplicationsCount :one
SELECT COUNT(*) AS total
FROM applications a
    JOIN users u ON a.user_id = u.id
    JOIN products p ON a.product_id = p.id
WHERE
    ($1::text IS NULL OR a.status = $1)
  AND ($2::text IS NULL OR p.type = $2)
  AND ($3::timestamp IS NULL OR a.created_at >= $3)
  AND ($4::timestamp IS NULL OR a.created_at <= $4)
  AND ($5::int IS NULL OR u.id = $5)
`

type GetManagerApplicationsCountParams struct {
	Column1 string           `db:"column_1" json:"column_1"`
	Column2 string           `db:"column_2" json:"column_2"`
	Column3 pgtype.Timestamp `db:"column_3" json:"column_3"`
	Column4 pgtype.Timestamp `db:"column_4" json:"column_4"`
	Column5 int32            `db:"column_5" json:"column_5"`
}

func (q *Queries) GetManagerApplicationsCount(ctx context.Context, arg *GetManagerApplicationsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getManagerApplicationsCount,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, full_name
FROM users
WHERE id = $1
`

type GetUserByIDParams struct {
	ID int32 `db:"id" json:"id"`
}

type GetUserByIDRow struct {
	ID       int32  `db:"id" json:"id"`
	FullName string `db:"full_name" json:"full_name"`
}

func (q *Queries) GetUserByID(ctx context.Context, arg *GetUserByIDParams) (*GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, arg.ID)
	var i GetUserByIDRow
	err := row.Scan(&i.ID, &i.FullName)
	return &i, err
}

const updateApplicationStatus = `-- name: UpdateApplicationStatus :one
UPDATE applications
SET
    status = $2,
    updated_at = NOW(),
    rejection_reason = $3
WHERE id = $1
    RETURNING id, status, updated_at
`

type UpdateApplicationStatusParams struct {
	ID              int32   `db:"id" json:"id"`
	Status          string  `db:"status" json:"status"`
	RejectionReason *string `db:"rejection_reason" json:"rejection_reason"`
}

type UpdateApplicationStatusRow struct {
	ID        int32            `db:"id" json:"id"`
	Status    string           `db:"status" json:"status"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateApplicationStatus(ctx context.Context, arg *UpdateApplicationStatusParams) (*UpdateApplicationStatusRow, error) {
	row := q.db.QueryRow(ctx, updateApplicationStatus, arg.ID, arg.Status, arg.RejectionReason)
	var i UpdateApplicationStatusRow
	err := row.Scan(&i.ID, &i.Status, &i.UpdatedAt)
	return &i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: applications.sql

package application

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications(user_id, product_id, data, calculated_price, manager_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, status, calculated_price, created_at
`

type CreateApplicationParams struct {
	UserID          *int32         `db:"user_id" json:"user_id"`
	ProductID       *int32         `db:"product_id" json:"product_id"`
	Data            []byte         `db:"data" json:"data"`
	CalculatedPrice pgtype.Numeric `db:"calculated_price" json:"calculated_price"`
	ManagerID       *int32         `db:"manager_id" json:"manager_id"`
}

type CreateApplicationRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg *CreateApplicationParams) (*CreateApplicationRow, error) {
	row := q.db.QueryRow(ctx, createApplication,
		arg.UserID,
		arg.ProductID,
		arg.Data,
		arg.CalculatedPrice,
		arg.ManagerID,
	)
	var i CreateApplicationRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CalculatedPrice,
		&i.CreatedAt,
	)
	return &i, err
}

const getApplicationByID = `-- name: GetApplicationByID :one
SELECT
    a.id,
    a.status,
    a.data,
    a.calculated_price,
    a.created_at,
    p.type AS product_type
FROM applications a
         JOIN products p ON a.product_id = p.id
WHERE a.id = $1
`

type GetApplicationByIDParams struct {
	ID int32 `db:"id" json:"id"`
}

type GetApplicationByIDRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	Data            []byte           `db:"data" json:"data"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	ProductType     string           `db:"product_type" json:"product_type"`
}

func (q *Queries) GetApplicationByID(ctx context.Context, arg *GetApplicationByIDParams) (*GetApplicationByIDRow, error) {
	row := q.db.QueryRow(ctx, getApplicationByID, arg.ID)
	var i GetApplicationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Data,
		&i.CalculatedPrice,
		&i.CreatedAt,
		&i.ProductType,
	)
	return &i, err
}

const getApplicationStatusHistory = `-- name: GetApplicationStatusHistory :many
SELECT
    old_status,
    new_status,
    changed_by,
    comment,
    created_at
FROM application_status_history
WHERE application_id = $1
ORDER BY created_at ASC
`

type GetApplicationStatusHistoryParams struct {
	ApplicationID *int32 `db:"application_id" json:"application_id"`
}

type GetApplicationStatusHistoryRow struct {
	OldStatus *string          `db:"old_status" json:"old_status"`
	NewStatus string           `db:"new_status" json:"new_status"`
	ChangedBy *int32           `db:"changed_by" json:"changed_by"`
	Comment   *string          `db:"comment" json:"comment"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) GetApplicationStatusHistory(ctx context.Context, arg *GetApplicationStatusHistoryParams) ([]*GetApplicationStatusHistoryRow, error) {
	rows, err := q.db.Query(ctx, getApplicationStatusHistory, arg.ApplicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetApplicationStatusHistoryRow
	for rows.Next() {
		var i GetApplicationStatusHistoryRow
		if err := rows.Scan(
			&i.OldStatus,
			&i.NewStatus,
			&i.ChangedBy,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplications = `-- name: GetApplications :many
SELECT
    a.id,
    a.status,
    a.calculated_price,
    a.created_at,
    p.type AS product_type
FROM applications a
         JOIN products p ON a.product_id = p.id
WHERE a.user_id = $1
  AND ($2::text IS NULL OR a.status = $2)
ORDER BY a.created_at DESC
    LIMIT $3 OFFSET $4
`

type GetApplicationsParams struct {
	UserID  *int32 `db:"user_id" json:"user_id"`
	Column2 string `db:"column_2" json:"column_2"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

type GetApplicationsRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	ProductType     string           `db:"product_type" json:"product_type"`
}

func (q *Queries) GetApplications(ctx context.Context, arg *GetApplicationsParams) ([]*GetApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getApplications,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetApplicationsRow
	for rows.Next() {
		var i GetApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CalculatedPrice,
			&i.CreatedAt,
			&i.ProductType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsCount = `-- name: GetApplicationsCount :one
SELECT COUNT(*) AS total
FROM applications
WHERE user_id = $1
  AND ($2::text IS NULL OR status = $2)
`

type GetApplicationsCountParams struct {
	UserID  *int32 `db:"user_id" json:"user_id"`
	Column2 string `db:"column_2" json:"column_2"`
}

func (q *Queries) GetApplicationsCount(ctx context.Context, arg *GetApplicationsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getApplicationsCount, arg.UserID, arg.Column2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

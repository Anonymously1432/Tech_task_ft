// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: applications.sql

package application

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countApplicationsByStatus = `-- name: CountApplicationsByStatus :one
SELECT COUNT(*) AS total
FROM applications
WHERE status = $1
`

type CountApplicationsByStatusParams struct {
	Status string `db:"status" json:"status"`
}

func (q *Queries) CountApplicationsByStatus(ctx context.Context, arg *CountApplicationsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countApplicationsByStatus, arg.Status)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countApplicationsByStatusAndDate = `-- name: CountApplicationsByStatusAndDate :one
SELECT COUNT(*) AS total
FROM applications
WHERE status = $1 AND updated_at >= $2 AND updated_at <= $3
`

type CountApplicationsByStatusAndDateParams struct {
	Status      string           `db:"status" json:"status"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	UpdatedAt_2 pgtype.Timestamp `db:"updated_at_2" json:"updated_at_2"`
}

func (q *Queries) CountApplicationsByStatusAndDate(ctx context.Context, arg *CountApplicationsByStatusAndDateParams) (int64, error) {
	row := q.db.QueryRow(ctx, countApplicationsByStatusAndDate, arg.Status, arg.UpdatedAt, arg.UpdatedAt_2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countApplicationsByStatusAndDateRange = `-- name: CountApplicationsByStatusAndDateRange :one
SELECT COUNT(*) AS total
FROM applications
WHERE status = $1 AND updated_at BETWEEN $2 AND $3
`

type CountApplicationsByStatusAndDateRangeParams struct {
	Status      string           `db:"status" json:"status"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	UpdatedAt_2 pgtype.Timestamp `db:"updated_at_2" json:"updated_at_2"`
}

func (q *Queries) CountApplicationsByStatusAndDateRange(ctx context.Context, arg *CountApplicationsByStatusAndDateRangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countApplicationsByStatusAndDateRange, arg.Status, arg.UpdatedAt, arg.UpdatedAt_2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications(user_id, product_id, data, calculated_price, manager_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, status, calculated_price, created_at
`

type CreateApplicationParams struct {
	UserID          *int32         `db:"user_id" json:"user_id"`
	ProductID       *int32         `db:"product_id" json:"product_id"`
	Data            []byte         `db:"data" json:"data"`
	CalculatedPrice pgtype.Numeric `db:"calculated_price" json:"calculated_price"`
	ManagerID       *int32         `db:"manager_id" json:"manager_id"`
}

type CreateApplicationRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg *CreateApplicationParams) (*CreateApplicationRow, error) {
	row := q.db.QueryRow(ctx, createApplication,
		arg.UserID,
		arg.ProductID,
		arg.Data,
		arg.CalculatedPrice,
		arg.ManagerID,
	)
	var i CreateApplicationRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CalculatedPrice,
		&i.CreatedAt,
	)
	return &i, err
}

const createApplicationComment = `-- name: CreateApplicationComment :exec
INSERT INTO application_comments (
    application_id,
    user_id,
    comment,
    created_at
) VALUES (
    $1,
    $3,
    $2,
    NOW()
)
`

type CreateApplicationCommentParams struct {
	ApplicationID *int32 `db:"application_id" json:"application_id"`
	Comment       string `db:"comment" json:"comment"`
	UserID        *int32 `db:"user_id" json:"user_id"`
}

func (q *Queries) CreateApplicationComment(ctx context.Context, arg *CreateApplicationCommentParams) error {
	_, err := q.db.Exec(ctx, createApplicationComment, arg.ApplicationID, arg.Comment, arg.UserID)
	return err
}

const createApplicationCommentt = `-- name: CreateApplicationCommentt :one
INSERT INTO application_comments (
    application_id,
    user_id,
    comment,
    created_at
) VALUES (
             $1,
             $2,
             $3,
             NOW()
         )
    RETURNING id, comment, created_at
`

type CreateApplicationCommenttParams struct {
	ApplicationID *int32 `db:"application_id" json:"application_id"`
	UserID        *int32 `db:"user_id" json:"user_id"`
	Comment       string `db:"comment" json:"comment"`
}

type CreateApplicationCommenttRow struct {
	ID        int32            `db:"id" json:"id"`
	Comment   string           `db:"comment" json:"comment"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateApplicationCommentt(ctx context.Context, arg *CreateApplicationCommenttParams) (*CreateApplicationCommenttRow, error) {
	row := q.db.QueryRow(ctx, createApplicationCommentt, arg.ApplicationID, arg.UserID, arg.Comment)
	var i CreateApplicationCommenttRow
	err := row.Scan(&i.ID, &i.Comment, &i.CreatedAt)
	return &i, err
}

const createApplicationStatusHistory = `-- name: CreateApplicationStatusHistory :exec
INSERT INTO application_status_history (
    application_id,
    old_status,
    new_status,
    changed_by,
    comment
)
VALUES ($1, $2, $3, $4, $5)
`

type CreateApplicationStatusHistoryParams struct {
	ApplicationID *int32  `db:"application_id" json:"application_id"`
	OldStatus     *string `db:"old_status" json:"old_status"`
	NewStatus     string  `db:"new_status" json:"new_status"`
	ChangedBy     *int32  `db:"changed_by" json:"changed_by"`
	Comment       *string `db:"comment" json:"comment"`
}

func (q *Queries) CreateApplicationStatusHistory(ctx context.Context, arg *CreateApplicationStatusHistoryParams) error {
	_, err := q.db.Exec(ctx, createApplicationStatusHistory,
		arg.ApplicationID,
		arg.OldStatus,
		arg.NewStatus,
		arg.ChangedBy,
		arg.Comment,
	)
	return err
}

const getApplicationByID = `-- name: GetApplicationByID :one
SELECT
    a.id,
    a.status,
    a.data,
    a.calculated_price,
    a.created_at,
    p.type AS product_type
FROM applications a
         JOIN products p ON a.product_id = p.id
WHERE a.id = $1
`

type GetApplicationByIDParams struct {
	ID int32 `db:"id" json:"id"`
}

type GetApplicationByIDRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	Data            []byte           `db:"data" json:"data"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	ProductType     string           `db:"product_type" json:"product_type"`
}

func (q *Queries) GetApplicationByID(ctx context.Context, arg *GetApplicationByIDParams) (*GetApplicationByIDRow, error) {
	row := q.db.QueryRow(ctx, getApplicationByID, arg.ID)
	var i GetApplicationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Data,
		&i.CalculatedPrice,
		&i.CreatedAt,
		&i.ProductType,
	)
	return &i, err
}

const getApplicationComments = `-- name: GetApplicationComments :many
SELECT
    ac.id,
    ac.comment,
    ac.created_at,
    u.id        AS author_id,
    u.full_name AS author_full_name
FROM application_comments ac
         JOIN users u ON ac.user_id = u.id
WHERE ac.application_id = $1
ORDER BY ac.created_at ASC
`

type GetApplicationCommentsParams struct {
	ApplicationID *int32 `db:"application_id" json:"application_id"`
}

type GetApplicationCommentsRow struct {
	ID             int32            `db:"id" json:"id"`
	Comment        string           `db:"comment" json:"comment"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	AuthorID       int32            `db:"author_id" json:"author_id"`
	AuthorFullName *string          `db:"author_full_name" json:"author_full_name"`
}

func (q *Queries) GetApplicationComments(ctx context.Context, arg *GetApplicationCommentsParams) ([]*GetApplicationCommentsRow, error) {
	rows, err := q.db.Query(ctx, getApplicationComments, arg.ApplicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetApplicationCommentsRow
	for rows.Next() {
		var i GetApplicationCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Comment,
			&i.CreatedAt,
			&i.AuthorID,
			&i.AuthorFullName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationStatus = `-- name: GetApplicationStatus :one
SELECT status
FROM applications
WHERE id = $1
`

type GetApplicationStatusParams struct {
	ID int32 `db:"id" json:"id"`
}

func (q *Queries) GetApplicationStatus(ctx context.Context, arg *GetApplicationStatusParams) (string, error) {
	row := q.db.QueryRow(ctx, getApplicationStatus, arg.ID)
	var status string
	err := row.Scan(&status)
	return status, err
}

const getApplicationStatusHistory = `-- name: GetApplicationStatusHistory :many
SELECT
    old_status,
    new_status,
    changed_by,
    comment,
    created_at
FROM application_status_history
WHERE application_id = $1
ORDER BY created_at ASC
`

type GetApplicationStatusHistoryParams struct {
	ApplicationID *int32 `db:"application_id" json:"application_id"`
}

type GetApplicationStatusHistoryRow struct {
	OldStatus *string          `db:"old_status" json:"old_status"`
	NewStatus string           `db:"new_status" json:"new_status"`
	ChangedBy *int32           `db:"changed_by" json:"changed_by"`
	Comment   *string          `db:"comment" json:"comment"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) GetApplicationStatusHistory(ctx context.Context, arg *GetApplicationStatusHistoryParams) ([]*GetApplicationStatusHistoryRow, error) {
	rows, err := q.db.Query(ctx, getApplicationStatusHistory, arg.ApplicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetApplicationStatusHistoryRow
	for rows.Next() {
		var i GetApplicationStatusHistoryRow
		if err := rows.Scan(
			&i.OldStatus,
			&i.NewStatus,
			&i.ChangedBy,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplications = `-- name: GetApplications :many
SELECT
    a.id,
    a.status,
    a.calculated_price,
    a.created_at,
    p.type AS product_type
FROM applications a
         JOIN products p ON a.product_id = p.id
WHERE (
    $1 IS NULL
        OR a.status = $1
    )
ORDER BY a.created_at DESC
    LIMIT $2 OFFSET $3
`

type GetApplicationsParams struct {
	Column1 interface{} `db:"column_1" json:"column_1"`
	Limit   int32       `db:"limit" json:"limit"`
	Offset  int32       `db:"offset" json:"offset"`
}

type GetApplicationsRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	ProductType     string           `db:"product_type" json:"product_type"`
}

func (q *Queries) GetApplications(ctx context.Context, arg *GetApplicationsParams) ([]*GetApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getApplications, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetApplicationsRow
	for rows.Next() {
		var i GetApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CalculatedPrice,
			&i.CreatedAt,
			&i.ProductType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsChartData = `-- name: GetApplicationsChartData :many
SELECT DATE(created_at) AS date,
    COUNT(*) FILTER (WHERE status = 'NEW') AS new,
    COUNT(*) FILTER (WHERE status = 'APPROVED') AS approved,
    COUNT(*) FILTER (WHERE status = 'REJECTED') AS rejected
FROM applications
WHERE created_at >= NOW() - INTERVAL '7 days'
GROUP BY DATE(created_at)
ORDER BY date ASC
`

type GetApplicationsChartDataRow struct {
	Date     pgtype.Date `db:"date" json:"date"`
	New      int64       `db:"new" json:"new"`
	Approved int64       `db:"approved" json:"approved"`
	Rejected int64       `db:"rejected" json:"rejected"`
}

func (q *Queries) GetApplicationsChartData(ctx context.Context) ([]*GetApplicationsChartDataRow, error) {
	rows, err := q.db.Query(ctx, getApplicationsChartData)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetApplicationsChartDataRow
	for rows.Next() {
		var i GetApplicationsChartDataRow
		if err := rows.Scan(
			&i.Date,
			&i.New,
			&i.Approved,
			&i.Rejected,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsConversion = `-- name: GetApplicationsConversion :one
SELECT
    COUNT(*) AS total,
    COUNT(*) FILTER (WHERE status = 'APPROVED') AS approved,
    COUNT(*) FILTER (WHERE status = 'REJECTED') AS rejected
FROM applications
WHERE created_at >= $1 and manager_id = $2
`

type GetApplicationsConversionParams struct {
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	ManagerID *int32           `db:"manager_id" json:"manager_id"`
}

type GetApplicationsConversionRow struct {
	Total    int64 `db:"total" json:"total"`
	Approved int64 `db:"approved" json:"approved"`
	Rejected int64 `db:"rejected" json:"rejected"`
}

func (q *Queries) GetApplicationsConversion(ctx context.Context, arg *GetApplicationsConversionParams) (*GetApplicationsConversionRow, error) {
	row := q.db.QueryRow(ctx, getApplicationsConversion, arg.CreatedAt, arg.ManagerID)
	var i GetApplicationsConversionRow
	err := row.Scan(&i.Total, &i.Approved, &i.Rejected)
	return &i, err
}

const getApplicationsCount = `-- name: GetApplicationsCount :one
SELECT COUNT(*) AS total
FROM applications a
WHERE user_id = $1
AND (
    $2 IS NULL OR a.status = $2
)
`

type GetApplicationsCountParams struct {
	UserID  *int32      `db:"user_id" json:"user_id"`
	Column2 interface{} `db:"column_2" json:"column_2"`
}

func (q *Queries) GetApplicationsCount(ctx context.Context, arg *GetApplicationsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getApplicationsCount, arg.UserID, arg.Column2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getApplicationsCountByStatus = `-- name: GetApplicationsCountByStatus :many
SELECT status, COUNT(*) AS total
FROM applications
WHERE created_at >= $1 and manager_id = $2
GROUP BY status
`

type GetApplicationsCountByStatusParams struct {
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	ManagerID *int32           `db:"manager_id" json:"manager_id"`
}

type GetApplicationsCountByStatusRow struct {
	Status string `db:"status" json:"status"`
	Total  int64  `db:"total" json:"total"`
}

func (q *Queries) GetApplicationsCountByStatus(ctx context.Context, arg *GetApplicationsCountByStatusParams) ([]*GetApplicationsCountByStatusRow, error) {
	rows, err := q.db.Query(ctx, getApplicationsCountByStatus, arg.CreatedAt, arg.ManagerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetApplicationsCountByStatusRow
	for rows.Next() {
		var i GetApplicationsCountByStatusRow
		if err := rows.Scan(&i.Status, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApplicationsCountByType = `-- name: GetApplicationsCountByType :many
SELECT p.type AS product_type, COUNT(*) AS total
FROM applications a
         JOIN products p ON a.product_id = p.id
WHERE a.created_at >= $1 and manager_id = $2
GROUP BY p.type
`

type GetApplicationsCountByTypeParams struct {
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	ManagerID *int32           `db:"manager_id" json:"manager_id"`
}

type GetApplicationsCountByTypeRow struct {
	ProductType string `db:"product_type" json:"product_type"`
	Total       int64  `db:"total" json:"total"`
}

func (q *Queries) GetApplicationsCountByType(ctx context.Context, arg *GetApplicationsCountByTypeParams) ([]*GetApplicationsCountByTypeRow, error) {
	rows, err := q.db.Query(ctx, getApplicationsCountByType, arg.CreatedAt, arg.ManagerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetApplicationsCountByTypeRow
	for rows.Next() {
		var i GetApplicationsCountByTypeRow
		if err := rows.Scan(&i.ProductType, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManagerApplicationByID = `-- name: GetManagerApplicationByID :one
SELECT
    a.id,
    a.status,
    a.data,
    a.calculated_price,
    a.created_at,
    p.type AS product_type,
    u.id        AS client_id,
    u.full_name AS client_full_name,
    u.email     AS client_email,
    u.phone     AS client_phone
FROM applications a
         JOIN users u ON a.user_id = u.id
         JOIN products p ON a.product_id = p.id
WHERE a.id = $1
`

type GetManagerApplicationByIDParams struct {
	ID int32 `db:"id" json:"id"`
}

type GetManagerApplicationByIDRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	Data            []byte           `db:"data" json:"data"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	ProductType     string           `db:"product_type" json:"product_type"`
	ClientID        int32            `db:"client_id" json:"client_id"`
	ClientFullName  *string          `db:"client_full_name" json:"client_full_name"`
	ClientEmail     string           `db:"client_email" json:"client_email"`
	ClientPhone     *string          `db:"client_phone" json:"client_phone"`
}

func (q *Queries) GetManagerApplicationByID(ctx context.Context, arg *GetManagerApplicationByIDParams) (*GetManagerApplicationByIDRow, error) {
	row := q.db.QueryRow(ctx, getManagerApplicationByID, arg.ID)
	var i GetManagerApplicationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Data,
		&i.CalculatedPrice,
		&i.CreatedAt,
		&i.ProductType,
		&i.ClientID,
		&i.ClientFullName,
		&i.ClientEmail,
		&i.ClientPhone,
	)
	return &i, err
}

const getManagerApplications = `-- name: GetManagerApplications :many
SELECT
    a.id,
    a.status,
    a.calculated_price,
    a.created_at,
    u.id AS client_id,
    u.full_name AS client_full_name,
    u.email AS client_email,
    p.type AS product_type
FROM applications a
         JOIN users u ON a.user_id = u.id
         JOIN products p ON a.product_id = p.id
ORDER BY a.created_at DESC
    LIMIT $1 OFFSET $2
`

type GetManagerApplicationsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type GetManagerApplicationsRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	ClientID        int32            `db:"client_id" json:"client_id"`
	ClientFullName  *string          `db:"client_full_name" json:"client_full_name"`
	ClientEmail     string           `db:"client_email" json:"client_email"`
	ProductType     string           `db:"product_type" json:"product_type"`
}

func (q *Queries) GetManagerApplications(ctx context.Context, arg *GetManagerApplicationsParams) ([]*GetManagerApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getManagerApplications, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetManagerApplicationsRow
	for rows.Next() {
		var i GetManagerApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CalculatedPrice,
			&i.CreatedAt,
			&i.ClientID,
			&i.ClientFullName,
			&i.ClientEmail,
			&i.ProductType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManagerApplicationsCount = `-- name: GetManagerApplicationsCount :one
SELECT COUNT(*) AS total
FROM applications a
JOIN users u ON a.user_id = u.id
JOIN products p ON a.product_id = p.id
`

func (q *Queries) GetManagerApplicationsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getManagerApplicationsCount)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getManagerApplicationsCountNew = `-- name: GetManagerApplicationsCountNew :one
SELECT COUNT(*)
FROM applications a
         JOIN users u ON a.user_id = u.id
         JOIN products p ON a.product_id = p.id
WHERE
    (array_length($1::text[], 1) IS NULL OR a.status = ANY($1))
  AND
    (array_length($2::text[], 1) IS NULL OR p.type = ANY($2))
  AND
    ($3::timestamp IS NULL OR a.created_at >= $3::timestamp)
  AND
    ($4::timestamp IS NULL OR a.created_at <= $4::timestamp)
  AND
    ($5::int IS NULL OR u.id = $5::int)
`

type GetManagerApplicationsCountNewParams struct {
	Statuses     []string         `db:"statuses" json:"statuses"`
	ProductTypes []string         `db:"product_types" json:"product_types"`
	DateFrom     pgtype.Timestamp `db:"date_from" json:"date_from"`
	DateTo       pgtype.Timestamp `db:"date_to" json:"date_to"`
	ClientID     *int32           `db:"client_id" json:"client_id"`
}

func (q *Queries) GetManagerApplicationsCountNew(ctx context.Context, arg *GetManagerApplicationsCountNewParams) (int64, error) {
	row := q.db.QueryRow(ctx, getManagerApplicationsCountNew,
		arg.Statuses,
		arg.ProductTypes,
		arg.DateFrom,
		arg.DateTo,
		arg.ClientID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getManagerApplicationsNew = `-- name: GetManagerApplicationsNew :many
SELECT
    a.id,
    a.status,
    a.calculated_price,
    a.created_at,
    u.id AS client_id,
    u.full_name AS client_full_name,
    u.email AS client_email,
    p.type AS product_type
FROM applications a
         JOIN users u ON a.user_id = u.id
         JOIN products p ON a.product_id = p.id
WHERE
    (array_length($3::text[], 1) IS NULL OR a.status = ANY($3))
  AND
    (array_length($4::text[], 1) IS NULL OR p.type = ANY($4))
ORDER BY a.created_at DESC
    LIMIT $1 OFFSET $2
`

type GetManagerApplicationsNewParams struct {
	Limit        int32    `db:"limit" json:"limit"`
	Offset       int32    `db:"offset" json:"offset"`
	Statuses     []string `db:"statuses" json:"statuses"`
	ProductTypes []string `db:"product_types" json:"product_types"`
}

type GetManagerApplicationsNewRow struct {
	ID              int32            `db:"id" json:"id"`
	Status          string           `db:"status" json:"status"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	ClientID        int32            `db:"client_id" json:"client_id"`
	ClientFullName  *string          `db:"client_full_name" json:"client_full_name"`
	ClientEmail     string           `db:"client_email" json:"client_email"`
	ProductType     string           `db:"product_type" json:"product_type"`
}

func (q *Queries) GetManagerApplicationsNew(ctx context.Context, arg *GetManagerApplicationsNewParams) ([]*GetManagerApplicationsNewRow, error) {
	rows, err := q.db.Query(ctx, getManagerApplicationsNew,
		arg.Limit,
		arg.Offset,
		arg.Statuses,
		arg.ProductTypes,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetManagerApplicationsNewRow
	for rows.Next() {
		var i GetManagerApplicationsNewRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CalculatedPrice,
			&i.CreatedAt,
			&i.ClientID,
			&i.ClientFullName,
			&i.ClientEmail,
			&i.ProductType,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentApplications = `-- name: GetRecentApplications :many
SELECT a.id, a.user_id AS client_id, u.full_name AS client_full_name, p.type AS product_type,
       a.status, a.calculated_price, a.created_at
FROM applications a
         JOIN users u ON a.user_id = u.id
         JOIN products p ON a.product_id = p.id
ORDER BY a.created_at DESC
    LIMIT $1
`

type GetRecentApplicationsParams struct {
	Limit int32 `db:"limit" json:"limit"`
}

type GetRecentApplicationsRow struct {
	ID              int32            `db:"id" json:"id"`
	ClientID        *int32           `db:"client_id" json:"client_id"`
	ClientFullName  *string          `db:"client_full_name" json:"client_full_name"`
	ProductType     string           `db:"product_type" json:"product_type"`
	Status          string           `db:"status" json:"status"`
	CalculatedPrice pgtype.Numeric   `db:"calculated_price" json:"calculated_price"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) GetRecentApplications(ctx context.Context, arg *GetRecentApplicationsParams) ([]*GetRecentApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getRecentApplications, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetRecentApplicationsRow
	for rows.Next() {
		var i GetRecentApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.ClientFullName,
			&i.ProductType,
			&i.Status,
			&i.CalculatedPrice,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, full_name
FROM users
WHERE id = $1
`

type GetUserByIDParams struct {
	ID int32 `db:"id" json:"id"`
}

type GetUserByIDRow struct {
	ID       int32   `db:"id" json:"id"`
	FullName *string `db:"full_name" json:"full_name"`
}

func (q *Queries) GetUserByID(ctx context.Context, arg *GetUserByIDParams) (*GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, arg.ID)
	var i GetUserByIDRow
	err := row.Scan(&i.ID, &i.FullName)
	return &i, err
}

const updateApplicationStatus = `-- name: UpdateApplicationStatus :one
UPDATE applications
SET
    status = $2,
    updated_at = NOW(),
    rejection_reason = $3
WHERE id = $1
    RETURNING id, status, updated_at
`

type UpdateApplicationStatusParams struct {
	ID              int32   `db:"id" json:"id"`
	Status          string  `db:"status" json:"status"`
	RejectionReason *string `db:"rejection_reason" json:"rejection_reason"`
}

type UpdateApplicationStatusRow struct {
	ID        int32            `db:"id" json:"id"`
	Status    string           `db:"status" json:"status"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateApplicationStatus(ctx context.Context, arg *UpdateApplicationStatusParams) (*UpdateApplicationStatusRow, error) {
	row := q.db.QueryRow(ctx, updateApplicationStatus, arg.ID, arg.Status, arg.RejectionReason)
	var i UpdateApplicationStatusRow
	err := row.Scan(&i.ID, &i.Status, &i.UpdatedAt)
	return &i, err
}
